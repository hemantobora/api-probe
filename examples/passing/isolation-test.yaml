# Variable Isolation Test
# Verifies that output variables don't leak between execution contexts

executions:
  - name: "Context A"
    vars:
      - CLIENT_ID: "client-A"
  
  - name: "Context B"
    vars:
      - CLIENT_ID: "client-B"
  
  - name: "Context C"
    vars:
      - CLIENT_ID: "client-C"

probes:
  # Probe 1: Capture a variable specific to this context
  - name: "Capture Context-Specific Token"
    type: rest
    endpoint: "https://httpbin.org/post"
    method: POST
    headers:
      Content-Type: "application/json"
    body:
      client_id: "${CLIENT_ID}"
      request_id: "${CLIENT_ID}-token"
    validation:
      status: 200
      body:
        equals:
          json.client_id: "${CLIENT_ID}"
    output:
      MY_TOKEN: "body.json.request_id"
  
  # Probe 2: Use the captured variable - should be context-specific
  - name: "Use Context Token"
    type: rest
    endpoint: "https://httpbin.org/post"
    method: POST
    headers:
      Content-Type: "application/json"
      X-Client-ID: "${CLIENT_ID}"
    body:
      token: "${MY_TOKEN}"
      client: "${CLIENT_ID}"
    validation:
      status: 200
      body:
        # Verify token matches this context's client ID
        equals:
          json.token: "${CLIENT_ID}-token"
          json.client: "${CLIENT_ID}"
        # Verify header echoed correctly
        present:
          - "headers.X-Client-Id"
        equals:
          headers.X-Client-Id: "${CLIENT_ID}"

# Verification:
# 
# If isolation works correctly:
# ✓ Context A: MY_TOKEN = "client-A-token", CLIENT_ID = "client-A"
# ✓ Context B: MY_TOKEN = "client-B-token", CLIENT_ID = "client-B"
# ✓ Context C: MY_TOKEN = "client-C-token", CLIENT_ID = "client-C"
#
# If isolation FAILS (variable leakage):
# ✗ Context B might use Context A's token
# ✗ Context C might use Context A's or B's token
# ✗ Validation would fail: token wouldn't match client_id
