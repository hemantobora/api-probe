# Variable Isolation Test
# Verifies that output variables don't leak between execution contexts
#
# Usage:
#   export CLIENT_ID="client-A,client-B,client-C"
#   ./run.sh examples/passing/isolation-test.yaml
#
# Expected Behavior:
# - Run 1: CLIENT_ID=client-A, captures TOKEN_A
# - Run 2: CLIENT_ID=client-B, captures TOKEN_B  
# - Run 3: CLIENT_ID=client-C, captures TOKEN_C
#
# Each run should ONLY see its own captured variables!

tests:
  # Test 1: Capture a variable specific to this context
  - name: "Capture Context-Specific Token"
    type: rest
    endpoint: "https://httpbin.org/post"
    method: POST
    headers:
      Content-Type: "application/json"
    body:
      client_id: "${CLIENT_ID}"
      request_id: "${CLIENT_ID}-token"
    validation:
      status: 200
      body:
        equals:
          json.client_id: "${CLIENT_ID}"
    output:
      MY_TOKEN: "body.json.request_id"
  
  # Test 2: Use the captured variable - should be context-specific
  - name: "Use Context Token"
    type: rest
    endpoint: "https://httpbin.org/post"
    method: POST
    headers:
      Content-Type: "application/json"
      X-Client-ID: "${CLIENT_ID}"
    body:
      token: "${MY_TOKEN}"
      client: "${CLIENT_ID}"
    validation:
      status: 200
      body:
        # Verify token matches this context's client ID
        equals:
          json.token: "${CLIENT_ID}-token"
          json.client: "${CLIENT_ID}"
        # Verify header echoed correctly
        present:
          - "headers.X-Client-Id"
        equals:
          headers.X-Client-Id: "${CLIENT_ID}"

# Verification:
# 
# If isolation works correctly:
# ✓ Run 1: MY_TOKEN = "client-A-token", CLIENT_ID = "client-A"
# ✓ Run 2: MY_TOKEN = "client-B-token", CLIENT_ID = "client-B"
# ✓ Run 3: MY_TOKEN = "client-C-token", CLIENT_ID = "client-C"
#
# If isolation FAILS (variable leakage):
# ✗ Run 2 might use Run 1's token
# ✗ Run 3 might use Run 1's or Run 2's token
# ✗ Validation would fail: token wouldn't match client_id
